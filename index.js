const { Client, GatewayIntentBits, EmbedBuilder, SlashCommandBuilder, REST, Routes } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, VoiceConnectionStatus, demuxProbe } = require('@discordjs/voice');
const play = require('play-dl');
const axios = require('axios');
const express = require('express');
require('dotenv').config();

// Config t·ª´ .env
const DISCORD_TOKEN = process.env.DISCORD_TOKEN;
const CLIENT_ID = process.env.CLIENT_ID;
const OPENWEATHER_API_KEY = process.env.OPENWEATHER_API_KEY;
const WELCOME_CHANNEL_ID = 'üí¨ùìíùì±ùì™ùìΩ';
const AUTO_ROLE_NAME = 'ü¶Ñ AKKA LOO';
const PORT = process.env.PORT || 3000;

// Express app setup
const app = express();

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildMembers
    ]
});

// Health check endpoints
app.get('/', (req, res) => {
    res.json({
        status: 'Bot is running! ü§ñ',
        uptime: `${Math.floor(process.uptime())} seconds`,
        timestamp: new Date().toISOString(),
        bot_status: client.isReady() ? 'online' : 'starting...',
        guilds: client.isReady() ? client.guilds.cache.size : 0
    });
});

app.get('/health', (req, res) => {
    res.json({
        status: 'healthy',
        bot_status: client.isReady() ? 'online' : 'offline',
        guilds: client.guilds.cache.size,
        uptime: process.uptime(),
        memory: process.memoryUsage()
    });
});

app.get('/ping', (req, res) => {
    res.send('Pong! üèì');
});

// Music queue system
const queue = new Map();

// Slash commands
const commands = [
    new SlashCommandBuilder()
        .setName('weather')
        .setDescription('Xem th·ªùi ti·∫øt')
        .addStringOption(option =>
            option.setName('city')
                .setDescription('T√™n th√†nh ph·ªë (VD: Ho Chi Minh City, Go Vap)')
                .setRequired(true)
        ),
    
    new SlashCommandBuilder()
        .setName('play')
        .setDescription('Ph√°t nh·∫°c t·ª´ YouTube')
        .addStringOption(option =>
            option.setName('query')
                .setDescription('Link YouTube ho·∫∑c t√™n b√†i h√°t')
                .setRequired(true)
        ),
    
    new SlashCommandBuilder()
        .setName('stop')
        .setDescription('D·ª´ng nh·∫°c v√† r·ªùi voice channel'),
    
    new SlashCommandBuilder()
        .setName('skip')
        .setDescription('B·ªè qua b√†i hi·ªán t·∫°i'),
    
    new SlashCommandBuilder()
        .setName('queue')
        .setDescription('Xem danh s√°ch ph√°t'),
    
    new SlashCommandBuilder()
        .setName('pause')
        .setDescription('T·∫°m d·ª´ng nh·∫°c'),
    
    new SlashCommandBuilder()
        .setName('resume')
        .setDescription('Ti·∫øp t·ª•c ph√°t nh·∫°c'),
    
    new SlashCommandBuilder()
        .setName('nowplaying')
        .setDescription('Xem b√†i ƒëang ph√°t')
];

// Register slash commands
const rest = new REST({ version: '10' }).setToken(DISCORD_TOKEN);

async function deployCommands() {
    try {
        console.log('ƒêang ƒëƒÉng k√Ω slash commands...');
        await rest.put(
            Routes.applicationCommands(CLIENT_ID),
            { body: commands }
        );
        console.log('‚úÖ ƒê√£ ƒëƒÉng k√Ω th√†nh c√¥ng slash commands!');
    } catch (error) {
        console.error('‚ùå L·ªói khi ƒëƒÉng k√Ω commands:', error);
    }
}

// Weather function
async function getWeather(city) {
    try {
        const cityMap = {
            'hcm': 'Ho Chi Minh City',
            'tphcm': 'Ho Chi Minh City',
            'tp hcm': 'Ho Chi Minh City',
            'go vap': 'Go Vap',
            'g√≤ v·∫•p': 'Go Vap',
            'ha noi': 'Hanoi',
            'h√† n·ªôi': 'Hanoi',
            'da nang': 'Da Nang',
            'ƒë√† n·∫µng': 'Da Nang',
            'can tho': 'Can Tho',
            'c·∫ßn th∆°': 'Can Tho'
        };
        
        const searchCity = cityMap[city.toLowerCase()] || city;
        
        const response = await axios.get(
            `https://api.openweathermap.org/data/2.5/weather?q=${searchCity},VN&appid=${OPENWEATHER_API_KEY}&units=metric&lang=vi`
        );
        
        const weather = response.data;
        
        const embed = new EmbedBuilder()
            .setTitle(`üå§Ô∏è Th·ªùi ti·∫øt t·∫°i ${weather.name}`)
            .setColor('#00ff00')
            .addFields(
                { name: 'üå°Ô∏è Nhi·ªát ƒë·ªô', value: `${Math.round(weather.main.temp)}¬∞C`, inline: true },
                { name: 'üå°Ô∏è C·∫£m gi√°c nh∆∞', value: `${Math.round(weather.main.feels_like)}¬∞C`, inline: true },
                { name: 'üíß ƒê·ªô ·∫©m', value: `${weather.main.humidity}%`, inline: true },
                { name: '‚òÅÔ∏è M√¥ t·∫£', value: weather.weather[0].description, inline: true },
                { name: 'üí® T·ªëc ƒë·ªô gi√≥', value: `${weather.wind.speed} m/s`, inline: true },
                { name: 'üëÅÔ∏è T·∫ßm nh√¨n', value: `${weather.visibility/1000} km`, inline: true }
            )
            .setFooter({ text: 'üáªüá≥ D·ªØ li·ªáu t·ª´ OpenWeatherMap' })
            .setTimestamp();
            
        return embed;
    } catch (error) {
        console.error('L·ªói khi l·∫•y th·ªùi ti·∫øt:', error);
        return new EmbedBuilder()
            .setTitle('‚ùå L·ªói')
            .setDescription('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt. Vui l√≤ng ki·ªÉm tra t√™n th√†nh ph·ªë!')
            .setColor('#ff0000');
    }
}

// Music functions
async function playMusic(guild, song) {
    const serverQueue = queue.get(guild.id);
    
    if (!song) {
        if (serverQueue && serverQueue.connection) {
            serverQueue.connection.destroy();
        }
        queue.delete(guild.id);
        return serverQueue?.textChannel?.send('‚úÖ ƒê√£ ph√°t h·∫øt nh·∫°c trong h√†ng ƒë·ª£i!');
    }
    
    try {
        console.log(`üéµ ƒêang chu·∫©n b·ªã ph√°t: ${song.title}`);
        
        // Ki·ªÉm tra l·∫°i URL tr∆∞·ªõc khi ph√°t
        const urlCheck = play.yt_validate(song.url);
        if (urlCheck !== 'video') {
            throw new Error('URL kh√¥ng h·ª£p l·ªá!');
        }
        
        // T·∫°o stream t·ª´ play-dl v·ªõi c√°c options t·ªëi ∆∞u
        const stream = await play.stream(song.url, { 
            quality: 2, // Ch·∫•t l∆∞·ª£ng cao
            filter: 'audioonly',
            seek: 0,
            discordPlayerCompatibility: true
        });
        
        if (!stream || !stream.stream) {
            throw new Error('Kh√¥ng th·ªÉ t·∫°o stream audio!');
        }
        
        const resource = createAudioResource(stream.stream, {
            inputType: stream.type,
            inlineVolume: true
        });
        
        // Set volume
        resource.volume?.setVolume(0.5);
        
        const player = createAudioPlayer();
        serverQueue.player = player;
        serverQueue.resource = resource;
        
        player.play(resource);
        serverQueue.connection.subscribe(player);
        
        // Player events
        player.on(AudioPlayerStatus.Playing, () => {
            console.log('‚úÖ Nh·∫°c ƒëang ph√°t!');
        });
        
        player.on(AudioPlayerStatus.Idle, () => {
            console.log('‚è≠Ô∏è B√†i h√°t k·∫øt th√∫c, chuy·ªÉn b√†i ti·∫øp theo...');
            serverQueue.songs.shift();
            setTimeout(() => {
                playMusic(guild, serverQueue.songs[0]);
            }, 1000);
        });
        
        player.on('error', error => {
            console.error('‚ùå Player error:', error);
            serverQueue.textChannel?.send(`‚ùå L·ªói khi ph√°t "${song.title}"! Chuy·ªÉn b√†i ti·∫øp theo...`);
            serverQueue.songs.shift();
            setTimeout(() => {
                playMusic(guild, serverQueue.songs[0]);
            }, 2000);
        });
        
        // Send now playing message
        const nowPlayingEmbed = new EmbedBuilder()
            .setTitle('üéµ ƒêang ph√°t')
            .setDescription(`**${song.title}**`)
            .addFields(
                { name: 'üé§ K√™nh', value: song.channel || 'Kh√¥ng r√µ', inline: true },
                { name: '‚è±Ô∏è Th·ªùi gian', value: song.duration || 'Kh√¥ng r√µ', inline: true },
                { name: 'üîó Link', value: `[YouTube](${song.url})`, inline: true }
            )
            .setColor('#00ff00')
            .setTimestamp();
            
        if (song.thumbnail) {
            nowPlayingEmbed.setThumbnail(song.thumbnail);
        }
        
        serverQueue.textChannel?.send({ embeds: [nowPlayingEmbed] });
        
    } catch (error) {
        console.error('‚ùå Play error:', error.message);
        serverQueue?.textChannel?.send(`‚ùå Kh√¥ng th·ªÉ ph√°t "${song.title}"! L·ªói: ${error.message}`);
        
        // Th·ª≠ b√†i ti·∫øp theo
        serverQueue.songs.shift();
        if (serverQueue.songs.length > 0) {
            setTimeout(() => {
                playMusic(guild, serverQueue.songs[0]);
            }, 3000);
        } else {
            serverQueue?.textChannel?.send('‚ùå Kh√¥ng c√≥ b√†i n√†o kh√°c ƒë·ªÉ ph√°t!');
            if (serverQueue && serverQueue.connection) {
                serverQueue.connection.destroy();
            }
            queue.delete(guild.id);
        }
    }
}

// Search YouTube
async function searchYouTube(query) {
    try {
        console.log(`üîç T√¨m ki·∫øm: ${query}`);
        
        // Ki·ªÉm tra xem c√≥ ph·∫£i URL YouTube kh√¥ng
        const urlValidation = play.yt_validate(query);
        console.log(`‚úÖ URL validation: ${urlValidation}`);
        
        if (urlValidation === 'video') {
            // N·∫øu l√† URL YouTube h·ª£p l·ªá
            console.log('üì∫ ƒêang l·∫•y th√¥ng tin video...');
            const info = await play.video_info(query);
            
            if (!info || !info.video_details) {
                throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin video t·ª´ URL n√†y!');
            }
            
            return {
                title: info.video_details.title || 'Unknown Title',
                url: info.video_details.url || query,
                duration: formatDuration(info.video_details.durationInSec || 0),
                thumbnail: info.video_details.thumbnails?.[0]?.url,
                channel: info.video_details.channel?.name || 'Unknown Channel'
            };
        } else {
            // T√¨m ki·∫øm theo t√™n
            console.log('üîé ƒêang t√¨m ki·∫øm tr√™n YouTube...');
            const searched = await play.search(query, { 
                limit: 3,
                source: { youtube: "video" }
            });
            
            if (!searched || searched.length === 0) {
                throw new Error(`Kh√¥ng t√¨m th·∫•y b√†i h√°t n√†o v·ªõi t·ª´ kh√≥a: "${query}"`);
            }
            
            const video = searched[0];
            console.log(`‚úÖ T√¨m th·∫•y: ${video.title}`);
            
            return {
                title: video.title || 'Unknown Title',
                url: video.url,
                duration: formatDuration(video.durationInSec || 0),
                thumbnail: video.thumbnails?.[0]?.url,
                channel: video.channel?.name || 'Unknown Channel'
            };
        }
    } catch (error) {
        console.error('‚ùå Search error:', error.message);
        
        // Th·ª≠ t√¨m ki·∫øm b·∫±ng c√°ch kh√°c n·∫øu URL fail
        if (query.includes('youtube.com') || query.includes('youtu.be')) {
            try {
                console.log('üîÑ Th·ª≠ ph∆∞∆°ng ph√°p t√¨m ki·∫øm kh√°c...');
                // Extract video ID t·ª´ URL
                let videoId = '';
                if (query.includes('v=')) {
                    videoId = query.split('v=')[1].split('&')[0];
                } else if (query.includes('youtu.be/')) {
                    videoId = query.split('youtu.be/')[1].split('?')[0];
                }
                
                if (videoId) {
                    const newUrl = `https://www.youtube.com/watch?v=${videoId}`;
                    const info = await play.video_info(newUrl);
                    
                    return {
                        title: info.video_details.title || 'Unknown Title',
                        url: newUrl,
                        duration: formatDuration(info.video_details.durationInSec || 0),
                        thumbnail: info.video_details.thumbnails?.[0]?.url,
                        channel: info.video_details.channel?.name || 'Unknown Channel'
                    };
                }
            } catch (retryError) {
                console.error('‚ùå Retry failed:', retryError.message);
            }
        }
        
        throw new Error(`Kh√¥ng th·ªÉ t√¨m th·∫•y ho·∫∑c ph√°t b√†i h√°t n√†y! L·ªói: ${error.message}`);
    }
}

// Format duration helper
function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// Bot events
client.once('ready', async () => {
    console.log(`‚úÖ Bot ƒë√£ online: ${client.user.tag}`);
    
    // Initialize play-dl
    try {
        await play.setToken({
            useragent: ['Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36']
        });
        console.log('‚úÖ Play-dl ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o!');
    } catch (error) {
        console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi t·∫°o play-dl token, s·∫Ω d√πng m·∫∑c ƒë·ªãnh');
    }
    
    await deployCommands();
    client.user.setActivity('üéµ Nh·∫°c & Th·ªùi ti·∫øt', { type: 'LISTENING' });
});

// Auto role when member joins
client.on('guildMemberAdd', async (member) => {
    try {
        const role = member.guild.roles.cache.find(r => r.name === AUTO_ROLE_NAME);
        if (role) {
            await member.roles.add(role);
            console.log(`‚úÖ ƒê√£ th√™m role "${AUTO_ROLE_NAME}" cho ${member.user.tag}`);
        }
        
        const welcomeChannel = member.guild.channels.cache.find(ch => ch.name.includes('chat') || ch.name.includes('üí¨'));
        if (welcomeChannel) {
            const embed = new EmbedBuilder()
                .setTitle('üéâ Ch√†o m·ª´ng th√†nh vi√™n m·ªõi!')
                .setDescription(`Xin ch√†o ${member.user}! Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi server! ü¶Ñ`)
                .setColor('#00ff00')
                .setThumbnail(member.user.displayAvatarURL())
                .setTimestamp();
            
            welcomeChannel.send({ embeds: [embed] });
        }
    } catch (error) {
        console.error('L·ªói khi x·ª≠ l√Ω th√†nh vi√™n m·ªõi:', error);
    }
});

// Slash command interactions
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isChatInputCommand()) return;
    
    const { commandName } = interaction;
    
    if (commandName === 'weather') {
        const city = interaction.options.getString('city');
        await interaction.deferReply();
        
        const weatherEmbed = await getWeather(city);
        await interaction.editReply({ embeds: [weatherEmbed] });
    }
    
    else if (commandName === 'play') {
        const query = interaction.options.getString('query');
        const voiceChannel = interaction.member.voice.channel;
        
        if (!voiceChannel) {
            return interaction.reply('‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc!');
        }
        
        await interaction.deferReply();
        
        try {
            console.log(`üéØ ƒêang x·ª≠ l√Ω: ${query}`);
            
            // Hi·ªÉn th·ªã tr·∫°ng th√°i ƒëang t√¨m ki·∫øm
            await interaction.editReply('üîç ƒêang t√¨m ki·∫øm b√†i h√°t...');
            
            const song = await searchYouTube(query);
            console.log(`‚úÖ T√¨m th·∫•y b√†i h√°t: ${song.title}`);
            
            const serverQueue = queue.get(interaction.guild.id);
            
            if (!serverQueue) {
                const queueContruct = {
                    textChannel: interaction.channel,
                    voiceChannel: voiceChannel,
                    connection: null,
                    songs: [],
                    volume: 5,
                    playing: true,
                    player: null,
                    resource: null
                };
                
                queue.set(interaction.guild.id, queueContruct);
                queueContruct.songs.push(song);
                
                try {
                    await interaction.editReply('üîó ƒêang k·∫øt n·ªëi voice channel...');
                    
                    const connection = joinVoiceChannel({
                        channelId: voiceChannel.id,
                        guildId: interaction.guild.id,
                        adapterCreator: interaction.guild.voiceAdapterCreator,
                    });
                    
                    queueContruct.connection = connection;
                    
                    // Wait for connection to be ready
                    connection.on(VoiceConnectionStatus.Ready, () => {
                        console.log('‚úÖ K·∫øt n·ªëi voice channel th√†nh c√¥ng!');
                        playMusic(interaction.guild, queueContruct.songs[0]);
                    });
                    
                    connection.on(VoiceConnectionStatus.Disconnected, () => {
                        console.log('‚ö†Ô∏è M·∫•t k·∫øt n·ªëi voice channel');
                        queue.delete(interaction.guild.id);
                    });
                    
                    connection.on('error', (error) => {
                        console.error('‚ùå Connection error:', error);
                        queue.delete(interaction.guild.id);
                    });
                    
                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i')
                        .setDescription(`**${song.title}**`)
                        .addFields(
                            { name: 'üé§ K√™nh', value: song.channel || 'Kh√¥ng r√µ', inline: true },
                            { name: '‚è±Ô∏è Th·ªùi gian', value: song.duration || 'Kh√¥ng r√µ', inline: true },
                            { name: 'üìç V·ªã tr√≠', value: '#1 (ƒêang ph√°t)', inline: true }
                        )
                        .setColor('#00ff00')
                        .setTimestamp();
                        
                    if (song.thumbnail) {
                        embed.setThumbnail(song.thumbnail);
                    }
                    
                    await interaction.editReply({ content: null, embeds: [embed] });
                    
                } catch (err) {
                    console.error('‚ùå L·ªói k·∫øt n·ªëi voice:', err);
                    queue.delete(interaction.guild.id);
                    await interaction.editReply('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi voice channel!');
                }
            } else {
                serverQueue.songs.push(song);
                const embed = new EmbedBuilder()
                    .setTitle('‚úÖ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i')
                    .setDescription(`**${song.title}**`)
                    .addFields(
                        { name: 'üìç V·ªã tr√≠', value: `#${serverQueue.songs.length}`, inline: true },
                        { name: 'üé§ K√™nh', value: song.channel || 'Kh√¥ng r√µ', inline: true },
                        { name: '‚è±Ô∏è Th·ªùi gian', value: song.duration || 'Kh√¥ng r√µ', inline: true }
                    )
                    .setColor('#00ff00')
                    .setTimestamp();
                    
                if (song.thumbnail) {
                    embed.setThumbnail(song.thumbnail);
                }
                
                await interaction.editReply({ content: null, embeds: [embed] });
            }
            
        } catch (error) {
            console.error('‚ùå Play command error:', error);
            await interaction.editReply({
                embeds: [new EmbedBuilder()
                    .setTitle('‚ùå L·ªói')
                    .setDescription(error.message)
                    .addFields(
                        { name: 'üí° G·ª£i √Ω', value: 'H√£y th·ª≠:\n‚Ä¢ Ki·ªÉm tra link YouTube c√≥ ƒë√∫ng kh√¥ng\n‚Ä¢ Th·ª≠ t√¨m ki·∫øm b·∫±ng t√™n b√†i h√°t\n‚Ä¢ ƒê·∫£m b·∫£o video kh√¥ng b·ªã ch·∫∑n ·ªü khu v·ª±c c·ªßa b·∫°n' }
                    )
                    .setColor('#ff0000')]
            });
        }
    }
    
    else if (commandName === 'stop') {
        const serverQueue = queue.get(interaction.guild.id);
        
        if (!serverQueue) {
            return interaction.reply('‚ùå Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t!');
        }
        
        if (serverQueue.player) {
            serverQueue.player.stop();
        }
        
        if (serverQueue.connection) {
            serverQueue.connection.destroy();
        }
        
        queue.delete(interaction.guild.id);
        
        await interaction.reply('‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi voice channel!');
    }
    
    else if (commandName === 'skip') {
        const serverQueue = queue.get(interaction.guild.id);
        
        if (!serverQueue || !serverQueue.player) {
            return interaction.reply('‚ùå Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t!');
        }
        
        serverQueue.player.stop();
        await interaction.reply('‚è≠Ô∏è ƒê√£ b·ªè qua b√†i hi·ªán t·∫°i!');
    }
    
    else if (commandName === 'pause') {
        const serverQueue = queue.get(interaction.guild.id);
        
        if (!serverQueue || !serverQueue.player) {
            return interaction.reply('‚ùå Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t!');
        }
        
        if (serverQueue.player.state.status === AudioPlayerStatus.Playing) {
            serverQueue.player.pause();
            await interaction.reply('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c!');
        } else {
            await interaction.reply('‚ùå Nh·∫°c kh√¥ng ƒëang ph√°t!');
        }
    }
    
    else if (commandName === 'resume') {
        const serverQueue = queue.get(interaction.guild.id);
        
        if (!serverQueue || !serverQueue.player) {
            return interaction.reply('‚ùå Kh√¥ng c√≥ nh·∫°c n√†o trong h√†ng ƒë·ª£i!');
        }
        
        if (serverQueue.player.state.status === AudioPlayerStatus.Paused) {
            serverQueue.player.unpause();
            await interaction.reply('‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c!');
        } else {
            await interaction.reply('‚ùå Nh·∫°c kh√¥ng b·ªã t·∫°m d·ª´ng!');
        }
    }
    
    else if (commandName === 'nowplaying') {
        const serverQueue = queue.get(interaction.guild.id);
        
        if (!serverQueue || serverQueue.songs.length === 0) {
            return interaction.reply('‚ùå Kh√¥ng c√≥ nh·∫°c n√†o ƒëang ph√°t!');
        }
        
        const currentSong = serverQueue.songs[0];
        const embed = new EmbedBuilder()
            .setTitle('üéµ ƒêang ph√°t')
            .setDescription(`**${currentSong.title}**`)
            .addFields(
                { name: 'üé§ K√™nh', value: currentSong.channel || 'Kh√¥ng r√µ', inline: true },
                { name: '‚è±Ô∏è Th·ªùi gian', value: currentSong.duration || 'Kh√¥ng r√µ', inline: true },
                { name: 'üîó Link', value: `[YouTube](${currentSong.url})`, inline: true }
            )
            .setColor('#00ff00')
            .setTimestamp();
            
        if (currentSong.thumbnail) {
            embed.setThumbnail(currentSong.thumbnail);
        }
        
        await interaction.reply({ embeds: [embed] });
    }
    
    else if (commandName === 'queue') {
        const serverQueue = queue.get(interaction.guild.id);
        
        if (!serverQueue || serverQueue.songs.length === 0) {
            return interaction.reply('‚ùå H√†ng ƒë·ª£i tr·ªëng!');
        }
        
        const embed = new EmbedBuilder()
            .setTitle('üéµ Danh s√°ch ph√°t')
            .setColor('#00ff00');
        
        const queueList = serverQueue.songs.slice(0, 10).map((song, index) => {
            const status = index === 0 ? 'üéµ **ƒêang ph√°t**' : `${index}.`;
            return `${status} ${song.title} - \`${song.duration}\``;
        }).join('\n');
        
        embed.setDescription(queueList || 'Tr·ªëng');
        
        if (serverQueue.songs.length > 10) {
            embed.setFooter({ text: `V√† ${serverQueue.songs.length - 10} b√†i kh√°c...` });
        }
        
        await interaction.reply({ embeds: [embed] });
    }
});

// Error handling
client.on('error', (error) => {
    console.error('‚ùå Client error:', error);
});

client.on('disconnect', () => {
    console.log('‚ö†Ô∏è Bot disconnected, attempting reconnect...');
});

client.on('reconnecting', () => {
    console.log('üîÑ Bot reconnecting...');
});

// Keep alive function
function keepAlive() {
    setInterval(() => {
        console.log('üíö Bot is alive! ' + new Date().toLocaleString('vi-VN'));
    }, 5 * 60 * 1000); // 5 ph√∫t
}

// Anti-crash
process.on('unhandledRejection', (reason, promise) => {
    console.log('‚ö†Ô∏è Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (err) => {
    console.log('‚ùå Uncaught Exception:', err);
});

// Start HTTP Server
app.listen(PORT, () => {
    console.log(`üåê HTTP Server ƒëang ch·∫°y tr√™n port ${PORT}`);
});

// Login v·ªõi retry
async function login() {
    try {
        await client.login(DISCORD_TOKEN);
        keepAlive();
        console.log('‚úÖ Bot ƒë√£ login th√†nh c√¥ng!');
    } catch (error) {
        console.error('‚ùå L·ªói login:', error);
        setTimeout(login, 5000); // Retry sau 5s
    }
}

login();